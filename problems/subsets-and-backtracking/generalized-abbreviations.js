"use strict"; // «TAGS» String, Number, Subsets, Permutations, Combinations, Recursive, Backtracking, Code, LC : #320 (Medium), Companies: Google

/*
Given a word, write a function to generate all of its unique generalized abbreviations.

A generalized abbreviation of a word can be generated by replacing each substring of the word with the count of characters in the substring. 
Take the example of “ab” which has four substrings: “”, “a”, “b”, and “ab”. After replacing these substrings in the actual word by the count 
of characters, we get all the generalized abbreviations: “ab”, “1b”, “a1”, and “2”.

All contiguous characters should be considered one substring (i.e. we can’t take “a” and “b” as substrings to get “11” -- since “a” and “b” are contiguous, 
we should consider them together as one substring to get an abbreviation “2”).

  EX's
    word = "BAT" → generalizedAbbreviations(word) = ["BAT", "BA1", "B1T", "B2", "1AT", "1A1", "2T", "3"]

    word = "code" → generalizedAbbreviations(word) = 
        ["code", "cod1", "co1e", "co2", "c1de", "c1d1", "c2e", "c3", "1ode", "1od1", "1o1e", "1o2", "2de", "2d1", "3e", "4"]
/*

n = # of characters in input string
+ RUNTIME Complexity: O(n·2^(n + 1)) [WST]
+ SPACE Complexity: O(n) [WST]
NOTE: In order to calculate our TIME complexity, we must first consider that we're generating '2 * 2^n' abbreviated strings 
which act as "nodes" in our recursion tree -- that being said, only the leaves of the tree end up being the complete abbreviations 
that we're looking for (we're generating '2^n' of such leaves). Furthermore, for every abbreviated string/node we're generating, 
we're calling the "substring" method on said string, which in the worst case will take O(n) time. Therefore, our TIME complexity should be: O(n * 2^n).
As for our SPACE complexity, the only memory we're using is that being used by the call stack which is holding our recursive calls. On that note,
in the worst case scenario, the most number of calls we'll be making at once will be proportional to the height of our recursion tree, which is itself 
proportional to our 'word' length (i.e. the # of characters in our original input string): 'n' 
*/

const generalizedAbbreviations = word => {
  let abbreviations = [];
  findAbbreviations();
  return abbreviations;

  function findAbbreviations(currAbb = "", idx = 0) {
    if (idx === word.length) abbreviations.push(currAbb);
    else {
      let lastEl = currAbb.charAt(currAbb.length - 1) || undefined;
      let addNum = !Number.isNaN(+lastEl) ? currAbb.substring(0, currAbb.length - 1) + (+lastEl + 1) : currAbb + "1";
      let addChar = currAbb + word.charAt(idx); 
      findAbbreviations(addNum, idx + 1);
      findAbbreviations(addChar, idx + 1);
    }
  }
};

// TESTING:
console.table(generalizedAbbreviations("BAT")); // Expect: ["BAT", "BA1", "B1T", "B2", "1AT", "1A1", "2T", "3"]
console.table(generalizedAbbreviations("code")); // Expect: ["code", "cod1", "co1e", "co2", "c1de", "c1d1", "c2e", "c3", "1ode", "1od1", "1o1e", "1o2", "2de", "2d1", "3e", "4"]
